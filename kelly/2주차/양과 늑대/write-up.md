## 👀 제한 시간 안에 어디까지 해냈는가?

`30분`안에 문제를 풀지 못했다. 30분 동안 어떻게 문제를 풀 수 있을지 풀이법도 떠올리지 못했다. 제법 어려운 문제라고는 하지만 마음이 아프다.

이런 다양한 아이디어의 문제를 많이 접하면서 단련을 계속해야겠다.

---

## 🧑‍🔬 문제 분석

늑대와 양의 위치를 담은 이진 트리 정보가 주어졌을 때 루트 노드 0을 시작으로 다른 노드를 순회하면서 모을 수 있는 최대 양의 개수를 구하는 문제이다.

- 참고로 노드에 처음 방문하면 그 노드에 있는 양/늑대가 따라오게 되는데 양의 개수는 늑대보다 항상 많도록 유지해야한다.

문제에 주어진 제약 조건은 다음과 같다.

- 2 ≤ `info`의 길이 ≤ 17
    - `info`의 원소는 0 또는 1 입니다.
    - info[i]는 i번 노드에 있는 양 또는 늑대를 나타냅니다.
    - 0은 양, 1은 늑대를 의미합니다.
    - info[0]의 값은 항상 0입니다. 즉, 0번 노드(루트 노드)에는 항상 양이 있습니다.
- `edges`의 세로(행) 길이 = `info`의 길이 - 1
    - `edges`의 가로(열) 길이 = 2
    - `edges`의 각 행은 [부모 노드 번호, 자식 노드 번호] 형태로, 서로 연결된 두 노드를 나타냅니다.
    - 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다.
    - 항상 하나의 이진 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다.
    - 0번 노드는 항상 루트 노드입니다.

---

## 🤔 풀이 고민

처음에는 BFS & DFS 방식을 떠올렸다. 하지만 이 방식으로는 문제를 해결하지 못한다. 이미 방문한 노드도 상황에 따라서는 다시 방문을 할 수 있기 때문이고 노드를 돌면서 양과 늑대의 개수를 조건에 맞게 조절하는 동시에 가질 수 있는 최대 양의 개수를 구해야 하기 때문에 BFS/DFS 방식의 코드로는 이 문제를 풀기 어렵다.

이 문제는 백트래킹 방식으로 풀어야 한다. 도달할 수 있는 모든 케이스를 탐색하면서 가능성이 없는 케이스는 제거해 시간 초과를 피하는 방식으로 문제를 풀어야한다.

문제를 처음 풀 때 가장 떠올리기 어려웠던건 이미 방문한 노드라도 상황에 따라 왔다갔다 하는 로직을 어떻게 백트래킹으로 구현하는가 였는데 핵심은 아래와 같다.

```sql
부모 노드는 방문한 적 있는데 자식 노드는 방문한 적 없는 케이스를 모두 탐색
```

위 케이스를 백트래킹으로 탐색하면서 그 과정에 모으게된 양의 개수를 계속 갱신해가면 결국 최대 크기의 양을 구할 수 있다.

참고로 가능성이 없는 케이스는 방문하지 않는 백트래킹 방식이므로 가능성이 없는 케이스를 판별하는 기준도 필요한데 이 기준은 위 핵심에서 조금만 생각하면 떠올릴 수 있다.

```sql
부모 -> 자식 방문 케이스를 visited로 관리
```

### 결론

- BFS & DFS로 풀기 어려운 문제이다.
- 백트래킹 방식으로 문제를 해결해야한다.

---

## 🏃 코드 작성 과정

### 구현하지 못한 부분 구현

이 문제는 아이디어조차 떠올리지 못한 문제이다. 풀이 역시 다른 사람의 정답을 확인하고 작성한 코드이다.

```python
def solution(info, edges):
    # 전역 데이터
    answer = 0
    
    # 메서드
    def back_tracking(s, w, visited):
        nonlocal answer
        
        if s <= w:
            return
        
        answer = max(answer, s)
        
        for p, c in edges:
            if visited[p] and not visited[c]:
                visited[c] = True
                if info[c] == 0:
                    back_tracking(s + 1, w, visited)
                else:
                    back_tracking(s, w + 1, visited)
                
                visited[c] = False
    
    # 메인 로직
    visited = [False] * len(info)
    
    visited[0] = True
    back_tracking(1, 0, visited)
    
    return answer
```

- 제일 고민된건 이미 부모는 방문했으면서 자식은 방문하지 않았는지에 대한 검증인데 막상 코드를 보니 너무 쉽게 해결해서 허무했다.
- 입력이 처음부터 부모 → 자식 정보로 넘겨줘서 편하기도 했다.

---

## 🥰 배운점 & 느낀점

- 이번 문제는 사실 아이디어를 떠올리지 조차 못했다.
- 이런 복잡한 아이디어의 문제를 최대한 많이 경험하고 기억해서 응용하는 연습을 계속 하는게 방법인거 같다.