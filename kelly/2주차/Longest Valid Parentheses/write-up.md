## 👀 제한 시간 안에 어디까지 해냈는가?

`30분`안에 문제를 풀지 못했다. 테스트 케이스를 모두 통과하는 코드까지 작성했지만 최종 제출 케이스에서 오답 처리를 받았다. 마지막까지 작성한 코드는 다음과 같다.

```python
# (()())

from collections import deque

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # 메인 로직
        answer = 0
        tmp = 0
        dq = deque(list(s))
        while dq:
            cur = dq.pop()
            if cur == "(":
                answer = max(answer, tmp)
                tmp = 0
            else:
                if not dq:
                    answer = max(answer, tmp)
                    break
                next = dq.pop()
                if next == "(":
                    tmp += 2
                    answer = max(answer, tmp)
                else:
                    dq.append(next)
                    answer = max(answer, tmp)
                    tmp = 0
        
        return answer
```

- Stack을 활용해야 한다는 생각까지는 했지만 근본적인 문제 해결책을 찾지 못했다.
- 그나마 작성한 코드는 `()()()` 같이 완전한 형태의 괄호가 이러지는 문자열은 올바르게 계산할 수 있지만 `()(())`같이 나중에 닫을 수 있는 문자열 케이스는 올바르게 계산하지 못한다.
- stack의 peek() 연산을 파이썬 deque에서 어떻게 하는지 몰라서 dq.popleft로 값을 확인 후 다시 dq.append()하는 괴랄한 연산을 사용했따…
    - 그냥 dq[-1] 혹은 dq[0]을 사용하면 된다.

---

## 🧑‍🔬 문제 분석

`(` 혹은 `)`로 구성된 문자열이 입력되면 그 문자열에서 괄호를 연속으로 닫을 수 있는 최대 개수를 구하는 문제이다.

문제에 주어진 제약 조건은 다음과 같다.

**Constraints:**

- `0 <= s.length <= 3 * 104`
- `s[i]` is `'('`, or `')'`.

---

## 🤔 풀이 고민

### Stack 활용

괄호 닫기 문제인 만큼 Stack을 활용해서 해결할 수 있는 문제이다. 다만 단순히 Stack을 활용하는걸 넘어 올바른 연속 길이를 구하는 아이디어가 필요한 문제이다.

연속 길이를 구하는 방법은 만약 괄호짝이 맞아 대상 문자열들을 스택에서 꺼낼 경우 현재 스택의 가장 위에 있는 문자의 인덱스를 당시 비교한 문자의 인덱스에서 빼면 연속 길이를 구할 수 있다.

`) ( ( ) ) ) ( ) ( ) ( )`

0 1 2 3 4 5 6 7 8 9 10 11

위 그림에서 가장 긴 연속 괄호 길이는 6이다.

- 길이가 6인 연속 괄호는 마지막에 비교된 11번째 닫는 괄호를 기준으로 6번째 문자열까지 팝이된다.
- 이 때 stack에 남아있는 가장 최상위 문자는 5번째 닫는 괄호이다.
- 따라서 마지막에 비교한 문자의 순서 11에서 해당하는 문자를 모두 스택에서 제거하고 남은 최상단 문자의 순서 5를 빼면 11 - 5 = 6 이렇게 계산하여 가장 긴 괄호의 길이를 쉽게 구할 수 있다.
- 만약 괄호짝이 맞는 문자를 모두 팝했을 때 stack이 비었다면 비교 대상 문자 순서에서 -1을 빼서 계산한다.
    - `()(())` 이 문자열을 비교시 가장 마지막 5번째 인덱스로 오는 닫는괄호로 인해 짝이 맞는 여는 괄호를 제거하면 stack이 비게된다. 이 때는 마지막에 비교한 문자의 인덱스 5에서 -1을 빼 길이 6을 얻을 수 있다.

문제에 주어지는 문자 길이는 최대 `3 * 10^4`인데 stack 연산은 O(1)이 소요되므로 충분히 이 아이디어로 문제를 해결할 수 있다.

### 결론

- Stack 활용 + 짝이 맞는 문자를 제거 후 스택 최상단에 남은 문자의 인덱스 혹은 스택이 비었을 경우 -1을 현재 비교한 닫는 괄호의 인덱스에서 빼면서 최대 길이 값을 갱신하는 아이디어로 문제를 해결할 수 있다.

---

## 🏃 코드 작성 과정

### 구현하지 못한 부분 구현

정답 아이디어에 살짝 접근하기는 했지만 근본적인 해결책을 떠올리지 못해 문제를 풀지 못했다. 올바른 아이디어를 코드로 구현하면 다음과 같다.

```python
from collections import deque

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        answer = 0
        dq = deque([-1])
        for i, v in enumerate(s):
            if v == "(":
                dq.append(i)
            else:
                dq.pop()
                if not dq:
                    dq.append(i)
                else:
                    answer = max(answer, i - dq[-1])
    
        return answer
```

### 틀린 부분 정정

- stack의 peek()을 파이썬 dq로 어떻게 해야할지 몰라서 dq.popleft()로 값 확인후 다시 dq.append()하는 코드를 작성했다.
- 단순히 가장 앞/뒤 데이터만 확인하고 싶다면 dq[0], dq[-1]하면 된다.

### 최종 정답 코드 개선

위에 구현한 코드를 최종적으로 사용하면 된다.

---

## 🥰 배운점 & 느낀점

- 이런 아이디어는 빠르게 떠올리지 못하기 때문에 당장 겪어본 케이스를 복습하며 응용을 연습해야할거 같다.