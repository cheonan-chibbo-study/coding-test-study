## 👀 제한 시간 안에 어디까지 해냈는가?

제한 시간 `30분안에` 테스트 케이스를 통과하는 풀이 코드를 작성해 제출했지만 대부분의 최종 채점 케이스에서 시간 초과 판정을 받았다. 결국 시간 초과 문제를 해결하지 못했다.

마지막으로 작성한 코드는 다음과 같다.

```python
# 15분 38초 남은, 정렬 뭐지
# 14분 22초 시간 초과 발생

from collections import deque

def solution(n, m, x, y, r, c, k):
    # 전역 데이터
    DIR = [[-1, 0, "u"], [0, 1, "r"], [0, -1, "l"], [1, 0, "d"]]
    x, y, r, c = x - 1, y - 1, r - 1, c - 1
    
    # 메서드
    def is_safe(t_r, t_c):
        return t_r >= 0 and t_r < n and t_c >= 0 and t_c < m
    
    # 메인 로직
    candi = []
    dq = deque([(x, y, "")])
    
    while dq:
        cur_r, cur_c, his = dq.popleft()
        
        if len(his) == k:
            if (cur_r, cur_c) == (r, c):
                candi.append(his)
            continue
        
        for dr, dc, dm in DIR:
            next_r, next_c = cur_r + dr, cur_c + dc
            
            if not is_safe(next_r, next_c):
                continue
            
            next_his = his + dm
            dq.append((next_r, next_c, next_his))
    
    if not candi:
        return "impossible"
    
    return sorted(candi)[0]
```

---

## 🧑‍🔬 문제 분석

문제에 주어진 조건들을 충족해 미로를 탈출할 수 있는 경로 혹은 탈출할 수 없다는 결과를 반환하는 문제이다.

- 자세한 내용은 문제를 살펴보자.

문제에 주어진 제약 조건은 다음과 같다.

### 제한사항

- 2 ≤ `n` (= 미로의 세로 길이) ≤ 50
- 2 ≤ `m` (= 미로의 가로 길이) ≤ 50
- 1 ≤ `x` ≤ `n`
- 1 ≤ `y` ≤ `m`
- 1 ≤ `r` ≤ `n`
- 1 ≤ `c` ≤ `m`
- (`x`, `y`) ≠ (`r`, `c`)
- 1 ≤ `k` ≤ 2,500

---

## 🤔 풀이 고민

처음 `k` 를 보자마자 BFS를 떠올렸고 대충 격자 크기가 최대 50 x 50으로 작으니까 BFS를 visited 없이 무지성 수행해도 문제를 해결할 수 있을거 생각했다. 하지만 이런 방식을 사용하면 시간 초과가 발생한다.

- visited가 없기 때문에 이동할 수 있는 4가지 경로를 시작으로 최대 k 크기인 2,500번의 이동이 발생할 수 있어 이 때 예상되는 시간 복잡도는 `O(4^2,500)`이다… 이미 여기서부터 이 방식으로는 절대 풀지 못하는 결론이 나온다.
- 내가 처음 작성한 코드는 k번으로 목적지에 도착할 수 있는 모든 문자열 경로를 수집 후 마지막에 문자열 리스트를 사전 정렬해서 첫 번째 요소를 반환하고 있다. 당장 이것만 해도 굉장히 많은 후보군이 모일경우 정렬에 큰 비용이 들 수 있다. (물론 첫번째 발생하는 4^2,500 연산으로 먼저 터진다…)

결론적으로 처음 내가 생각한 방식은 너무 많은 경우의 수를 탐색하기 때문에 BFS 탐색 횟수를 크게 줄일 아이디어가 필요했다. 이 아이디어를 혼자서 찾지는 못해 결국 구글링을 했고 다음과 같은 아이디어를 얻을 수 있었다.

### Manhattan 공식으로 목적지 까지 최단 거리를 구한 후 도달 가능한 케이스만 구성하기

`Manhattan` 거리 공식을 활용하면 시작 위치에서 도착 위치 까지의 최단 거리를 구할 수 있다. 만약 (x1, y1) → (x2, y2)의 최단 거리를 구하고 싶다면 다음과 같다.

- `abs(x2 - x1) + abs(y2 - y1)`

manhattan 공식으로 최단 거리를 확보했다면 이제 이 값을 활용해 경우의 수를 줄여야 한다. 아이디어는 다음과 같다.

- 각 케이스에서 다음 이동 경로를 바로 큐에 넣지 말고, 다음 이동하는 포인트에서 최단 거리 만에 이동할 수 있는 거리가 남았는지 검사한다.
- 만약 현재 남은 이동 횟수로 목적지에 도달하는 최단 거리를 갈 수 있을 경우, (현재 남은 횟수 - 최단거리) 값이 짝수인지 검사한다.
    - 만약 내가 이동거리가 4 남았는데 최단 거리까지 3이라고 가정할 경우, 우선 3으로 목적지에 도착후 남은 횟수를 제거해야하는데 문제는 남은 횟수가 홀수이면 다시 목적지로 돌아올 수 없다. 따라서 이 경우는 목적지에 도달할 수 없는 경우로 간주한다.

이 아이디어를 활용하면 애초에 목적지에 도착할 수 없는 경우는 큐에 넣지 않기 때문에 탐색 횟수를 줄일 수 있다.

### DIR 배열 요소 순서를 사전순으로 설정 & 4방향 중 목적지에 도달할 수 있는 경우가 발생하면 조기 종료

내가 처음 작성한 코드의 문제점 중 하나는 이동 가능한 모든 문자 경로를 모아 정렬하는 비효율적인 로직의 존재이다. 이 비효율 역시 위 소제목 방식으로 없엘 수 있다.

애초에 이동 방향 중 사전순으로 가장 빠른 방향부터 검사해서 이동 가능한 방향이 나오면 남은 방향은 굳이 탐색할 필요가 없다. 애초에 남은 방향은 사전순으로 밀리기 때문에 탐색해도 그 케이스는 전부 후보에 들지 못한다.

### 정리

- 내 기존 코드는 visited가 없어 최대 4^2,500번 탐색 + 사전순으로 후보에 들 수 없는 경우까지 모두 탐색하는 비효울 로직으로 시간 초과가 발생한다.
- 따라서 위에 기술한 아이디어들을 적용해서 탐색 횟수를 대폭 낮춰야한다.

---

## 🏃 코드 작성 과정

### 최종 정답 코드 작성

기존에 내가 작성한 코드에서 위 아이디어를 적용해 다음과 같이 개선했다. 이 코드는 최종 정답 처리를 받는다.

```python
from collections import deque

def solution(n, m, x, y, r, c, k):
    # 전역 데이터
    DIR = [[1, 0, "d"], [0, -1, "l"], [0, 1, "r"], [-1, 0, "u"]]
    x, y, r, c = x - 1, y - 1, r - 1, c - 1
    
    # 메서드
    def is_safe(t_r, t_c):
        return t_r >= 0 and t_r < n and t_c >= 0 and t_c < m
    
    def manhattan(row, col):
        return abs(r - row) + abs(c - col)
    
    # 메인 로직
    if manhattan(x, y) > k or (k - manhattan(x, y)) % 2:
        return "impossible"
    
    dq = deque([(x, y, "")])
    while dq:
        cur_r, cur_c, his = dq.popleft()

        if (cur_r, cur_c) == (r, c):
            if len(his) == k:
                return his
            elif (k - len(his) - manhattan(cur_r, cur_c)) % 2:
                return "impossible"
        
        for dr, dc, dm in DIR:
            next_r, next_c = cur_r + dr, cur_c + dc
            
            if not is_safe(next_r, next_c) or manhattan(next_r, next_c) + len(his) + 1 > k:
                continue

            dq.append((next_r, next_c, his + dm))
            break
    
    return "impossible"

```

---

## 🥰 배운점 & 느낀점

- 솔직히 문제 구현이 어렵지 않고 격자도 대충 봤는데 크기가 작은거 같아서 효율성은 생각도 못하고 무지성으로 코드를 짰다. 그래서 16분만에 구현 끝내고 제출했지만 결국 효율성을 충족하지 못해 문제를 풀지 못했다.
- 이제 어느정도 코드 구현은 할 수 있으니 시간/공간 효율성을 고려하는 훈련을 해야할거 같다. 그리고 manhattan 같이 좋은 아이디어는 정리해서 암기하고 체화할 필요가 있을거 같다.