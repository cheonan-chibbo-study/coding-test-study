## 문제 분석
주어진 문자열 s를 분할했을 때 그 부분 문자열들이 모두 palindrome인 경우를 모두 반환하는 문제이다.

참고로 palindrome은 앞으로 읽거나 뒤로 읽어도 모두 같은 문자열을 의미한다.

문제에 주어진 제한 조건은 다음과 같다.

- `1 <= s.length <= 16`
- `s` contains only lowercase English letters.

## 풀이 고민
### 완전 탐색
주어진 문자열 내부에 속한 각 문자들 사이에 파티션을 놓을지 말지에 대한 모든 경우의 수를 찾아 palindrome 여부를 검사하는 방식을 먼저 떠올려 볼 수 있다.

문자열 길이를 `n`이라고 할 때, 문자열 내부의 각 문자 사이에 파티션을 놓을지 말지에 대한 모든 경우의 수는 `2^(n - 1)` 이다.

그리고 각 경우에 대해 palindrome 여부를 검사하는데 최대 n번의 연산이 소요되므로 이 풀이의 최종 Big(O) 시간 복잡도는 `n * 2^(n - 1)`로 예상할 수 있다.

이 문제에 주어지는 최대 n 값은 16이므로 최대 `16 * 2^15 (524,288)`번 연산이 발생할 수 있다. 십만 단위의 연산 횟수 이므로 충분히 이 풀이로 문제를 해결할 수 있다.

### 결론

- 완전 탐색을 활용하면 최대 `n * 2^(n - 1)` → `16 * 2^15 (524,288)` 의 시간 복잡도가 소요되므로 이 방식으로 문제를 해결할 수 있다.