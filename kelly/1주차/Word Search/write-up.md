## 문제 분석
주어진 격자를 탐색하여 주어진 word 문자열이 격자 내부에 연속해서 존재하는지 여부를 반환하는 문제이다.

문제에서 주어진 입력 값 범위는 다음과 같다.

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- board and word consists of only lowercase and uppercase English letters.

주어지는 격자 요소의 최대 개수는 다음과 같다.

- m = 6, n = 6일 때, 6 * 6 == `36개`

### 완전 탐색 (재귀 + 백트래킹)

완전 탐색을 사용해서 문제를 풀 경우 아래와 같은 플로우로 구성된다.

- 격자를 돌면서 시작 위치를 선택 → `최대 36번`
- 하나의 요소를 시작으로 격자 탐색, 도달하는 요소를 기준으로 총 4방향의 탐색을 매번 진행함 → `최대 4^15번` (15 = 문자열 최대 길이)
    - 문자열 길이가 최대 15이고, 문자열의 요소 하나당 4개의 선택지가 있으므로 최악의 경우 4개 선택 * 4개 선택 * 4개 선택 * …

즉, 완전 탐색을 사용하면 최악의 경우 O(36 * 4^15) → `O(38,654,705,664)` 의 시간 복잡도가 예상된다.

대략 380억의 연산이기 때문에 완전 탐색으로는 절대 해결할 수 없을거 같지만 백트래킹 특성상 아래와 같은 부분들이 연산 횟수를 크게 줄여준다.

- 처음 최대 36개의 선택지 중 대상 문자열의 첫 글자와 일치하지 않는 선택지는 아예 탐색하지 않기 때문에 경우의 수가 줄어든다.
- 4방향 탐색 시 대상 문자열에 일치하지 않는 문자 선택지, 혹은 이미 방문한 선택지는 다시 방문하지 않기 때문에 이 부분에서 경우의 수가 또 줄어든다.

따라서 실제로는 모든 경우들을 전부 탐색하지 않기 때문에 백트래킹으로 충분히 문제를 해결할 여지가 있다.

### 결론
- 가능성이 없는 선택지를 줄여 나가는 백트래킹의 특성을 잘 활용한다면 문제를 충분히 해결할 수 있다.

## 배운점 & 느낀점
- 단순 계산으로는 1억을 매우 초과하는 연산이라도 백트래킹의 가지치기가 크게 작용한다면 완전 탐색으로 충분히 해결할 수 있음을 느꼈다.
- 격자 문제는 visited 처리 등의 실수가 많이 발생하므로 꼼꼼하게 코드를 작성할 필요가 있다.ㄴ