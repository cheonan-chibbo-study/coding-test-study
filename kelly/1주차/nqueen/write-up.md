## 👩‍🚀 문제 분석

n * n 크기의 체스판에서 n개의 퀸을 놓을 수 있는 경우의 수를 모두 찾아 문자열 형태로 반환하는 문제입니다.

문제에 주어진 제약 조건은 다음과 같습니다.

**Constraints:**

- `1 <= n <= 9`

## 🤔 풀이 고민

### 완전 탐색 (백트래킹)

주어지는 n의 최대 값이 작은 수이기 때문에 완전 탐색 방식을 먼저 떠올렸습니다. n의 최대 값인 9라고 가정하면 9 * 9 크기의 체스판에 9개의 퀸을 모두 놓을 수 있는 경우의 수를 격자 하나하나에 퀸을 두는 방식으로 문제를 푸는 방법을 생각해 볼 수 있습니다.

이 방식을 사용할 경우 예상 시간 복잡도를 계산해보겠습니다. 우선 단순하게 생각하면 퀸은 한 줄에 하나만 올 수 있기 때문에 한 줄에 퀸을 하나만 둔다고 가정하면 n = 3이라고 가정했을 때

- 첫 번째 줄에 첫 번째 퀸이 올 수 있는 경우의 수 → 3
- 두 번째 줄에 두 번째 퀸이 올 수 있는 경우의 수 → 3
- 세 번째 줄에 세 번째 퀸이 올 수 있는 경우의 수 → 3

n = 3일 경우 각 줄마다 퀸을 배치할 수 있는 모든 경우의 수를 따졌을 때 `3^3(27)`번의 연산이 필요함을 알 수 있습니다. 즉, 이 문제를 완전 탐색으로 풀려고 시도하면 최대 `n^n` → `9^9(387,420,489)`번의 연산이 소요됩니다.

대략 `10^8` 번의 연산이 필요하므로 완전 탐색, 특히 재귀로 작성하는 코드로는 이 문제를 풀 수 없을거 같습니다. 하지만 이 경우는 퀸이 한 줄에 하나만 올 수 있다는 전제 조건만 따졌을 때 발생하는 연산 횟수이기 때문에 퀸의 다른 조건들을 따지면서 아예 조건에 맞지 않는 경우의 수를 백트래킹으로 제외한다면 연산의 수를 대폭 줄일 수 있습니다.

물론 백트래킹 특성상 정확한 연산 횟수를 측정하기는 어렵지만 퀸의 배치 조건이 많이 까다롭기 때문에 백트래킹으로 처음부터 불가능한 케이스를 건너뛰며 연산하면 충분히 재귀 코드로도 해결할 수 있을거 같습니다.

## 배운점 & 느낀점
- 단순 시간 복잡도 계산으로는 당연히 완전 탐색으로 해결하지 못할거라고 생각했는데 실제로는 백트래킹 과정에서 많은 경우의 수가 탈락하여 재귀 코드로도 충분히 풀리는게 신기했습니다.
- 솔직히 실전에서 이 문제 만났으면 풀 수 있을지... 모르겠습니다.